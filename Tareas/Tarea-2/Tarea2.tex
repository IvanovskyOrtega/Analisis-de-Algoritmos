\documentclass[12pt, letterpaper, twoside]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{gauss}
\usepackage[document]{ragged2e}
\usepackage{listings}
\usepackage{color}
\usepackage{inconsolata}
\definecolor{gris}{rgb}{0.4,0.4,0.4}
\definecolor{verde}{rgb}{0,0.8,0.6}
\definecolor{anaranjado}{rgb}{1.0,0.4,0}
\lstset{
language=C,
basicstyle=\footnotesize\ttfamily,
commentstyle=\color{anaranjado},
frame=single,
keywordstyle=\color{verde},
showspaces=false,
showstringspaces=false,
stringstyle=\color{anaranjado},
tabsize=2
}
\newcommand{\mline}{%
  \hspace{-\arraycolsep}%
  \strut\vrule
  \hspace{-\arraycolsep}%
}
 
\title{\textbf{Instituto Politécnico Nacional
			\vspace{10mm}	 \ \newline	
			Escuela Superior de Cómputo}
			\vspace{10mm}	 \ \newline	
			Análisis de Algoritmos
			\vspace{10mm}	 \ \newline	
			Profesor: Edgardo Adrián Franco Martínez}
\author{Alumno: Ortega Victoriano Ivan}
\date{Fecha: 24 de Marzo 2017}
 
\begin{document}
\begin{titlepage}
\maketitle
\end{titlepage}
\justify
\textbf{Análisis de algoritmos recursivos.}\newline
\textbf{Ejercicio 1:} Calcular la complejidad para el siguiente algoritmo. 
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

int FuncionRecursiva(int num )
{
  if ( num == 0 )
    return 1;
  else if ( num < 3 )
  {
    int resultado=0;
    for(int i=0;i<num*num;i++)
      resultado*=num;
    return resultado;
  }
  else
    return FuncionRecursiva( num - 1 )*
    FuncionRecursiva(num - 2)/FuncionRecursiva(num - 3);
}
\end{lstlisting}
\justify
\textbf{\textit{Sol:}}
Del algoritmo podemos ver que si $n = 0$, entonces $T(0) = 1$, además si $n = 1$ entonces $T(1) = 5$ (comparar 1 vez el \textit{if} de la función, 1 asignación de la variable resultado, 1 ejecución del for, 2 comparaciones del for), y por último si $n = 2$ entonces $T(2) = 9$ (se analiza igual que el caso de $n = 1$). Los análisis anteriores son para los costos de los casos base.
\newline
Ahora, analizando para un $n$ en general, tendremos que:
\[T(n) = T(n-1)+c_{mult}+T(n-2)+c_{div}+T(n-3)\]
Donde $c_{mult}=c_{div}=1$, luego:
\[T(n) = T(n-1)+T(n-2)+T(n-3)+2\]
Que se trata de una ecuación en recurrencia no homogénea.
\newline
Reacomodando la ecuación, tenemos:
\[T(n)-T(n-1)-T(n-2)-T(n-3)=2\]
Haciendo el cambio $T(n) = x^{3}$, $b = 2$ y $d = 0$, obtenemos la ecuación característica:
\[(x^{3}-x^{2}-x-1)(x-2)=0\]
De donde las raíces son:
\[r_{1}=1.84\]
\[r_{2}=-0.42+i0.61\]
\[r_{3}=-0.42-i0.61\]
\[r_{4}=2\]
Que son raíces distintas, así:
\[T(n)=c_{1}(1.84)^{n}+c_{2}(-0.42+i0.61)^{n}+c_{3}(-0.42-i0.61)^{n}+c_{4}2^{n}\]
\justify
Dado que tenemos dos números complejos, de acuerdo con sus propiedades, la ecuación puede reescribirse de la siguiente manera:
\[T(n)=c_{1}(1.84)^{n}+c_{2}(0.73^{n}(\cos(124.68)+i\sin(124.68)))\]
\[+c_{3}(0.73^{n}(\cos(124.68n)-i\sin(124.68n)))+c_{4}2^{n}\]
Luego
\[T(n)=c_{1}(1.84)^{n}+0.73^{n}((c_{2}+c_{3})\cos(124.68n)+(c_{2}-c_{3})i\sin(124.68n)))+c_{4}2^{n}\]
Llamemos $k_{1}=c_{2}+c_{3}$ y $k_{2}=(c_{2}-c_{3})i$, así
\[T(n)=c_{1}(1.84)^{n}+0.73^{n}(k_{1}\cos(124.68n)+k_{2}\sin(124.68n)))+c_{4}2^{n}\]
Evaluando las condiciones iniciales
\[T(0)=c_{1}+k_{1}+c_{4}\]
\[T(1)=1.84c_{1}-0.41k_{1}+0.60k_{2}+2c_{4}\]
\[T(2)=3.38c_{1}-0.18k_{1}-0.49k_{2}+4c_{4}\]
Como $T(3) = T(2) + T(1) + T(0) + 2$ entonces:
\[1+5+9+2 = 6.22c_{1}+0.41k_{1}+0.11k_{2}+7c_{4}+2\]
Luego
\[1=c_{1}+k_{1}+c_{4}\]
\[5=1.84c_{1}-0.41k_{1}+0.60k_{2}+2c_{4}\]
\[9=3.38c_{1}-0.18k_{1}-0.49k_{2}+4c_{4}\]
\[15=6.22c_{1}+0.41k_{1}+0.11k_{2}+7c_{4}\]
\justify
Que es el sistema de ecuaciones resultante de la evaluacion de las condiciones iniciales. 
\newline
Pasando este sistema a la matriz aumentada, tenemos:
\begin{align} 
    \begin{gmatrix}[p] 
        1    &    1  &  0    & 1 & \mline & 1 \\
        1.84 & -0.41 &  0.60 & 2 & \mline & 5 \\
        3.38 & -0.18 & -0.49 & 4 & \mline & 9 \\
        6.22 &  0.41 &  0.11 & 7 & \mline & 15
    \end{gmatrix} 
\end{align}
Resolviendo la matriz por Gauss-Jordan, se llega a la solución:
\begin{align} 
    \begin{gmatrix}[p] 
        1 & 0 & 0 & 0 & \mline & -1.581 \\
        0 & 1 & 0 & 0 & \mline & -1.018 \\
        0 & 0 & 1 & 0 & \mline &  0.486 \\
        0 & 0 & 0 & 1 & \mline &  3.6
    \end{gmatrix} 
\end{align}
Que es equivalente a que
\[c_{1}=-1.581\]
\[k_{1}=-1.018\]
\[k_{2}=0.486\]
\[c_{4}=3.6\]
\center
$\therefore T(n) = -1.581(1.84)^{n}+0.73^{n}[(0.486)\sin(n\theta)-(1.018)\cos(n\theta)]+(3.6)2^{n}$
En donde $\theta = 124.68$
\vspace{10mm}
\newline
\justify
\textbf{Comentario:} Al parecer hay unos cuantos errores en cuanto a lo que hace el algoritmo, de hecho, en la parte donde $n < 3$, al hacer a $resultado = 0$, este valor nunca va a cambiar, ya que en el loop \textit{for} se hace la operación $resultado*=num$, pero como $resultado = 0$, siempre va a retornar un valor de cero. De lo que a partir de un $ n > 3$ va a haber divisiones entre 0, lo cual será un error en el programa. 
\newpage
\textbf{Ejercicio 2:} Calcular la complejidad de la implementación recursiva del termino n de la serie de Tribonacci (0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, ...)
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

int Tribonacci( int num )
{
  if (num==0)
    return 0;
  else if (num==1||num==2)
    return 1;
  else
    return Tribonacci(num-1)+Tribonacci(num-2)+Tribonacci(num-3);
}
\end{lstlisting}
\justify
\textbf{\textit{Sol:}}
Si nos damos cuenta, el análisis es similar al caso anterior, solo hay ligeras modificaciones en cuanto a las conidiciones iniciales y a la ecuacion en recurrencia.
\newline
Es evidente que $T(0) = 1$, $T(1) = T(2) = 2$, ya que son las comparaciones que se hacen al entrar a la función.
\newline
Ahora para un $n$ en general:
\[T(n) = T(n-1)+T(n-2)+T(n-3)+4\]
Donde el 4 resulta de las dos comparaciones de la función, mas el costo de las 2 sumas.
\newline
Que avanzando un poco más (ya que el análisis es exactamente igual al del ejercicio anterior), la ecuación característica quedaría de la siguiente manera:
\[(x^{3}-x^{2}-x-1)(x-4)=0\]
Donde nuestras raíces ahora son:
\[r_{1}=1.84\]
\[r_{2}=-0.42+i0.61\]
\[r_{3}=-0.42-i0.61\]
\[r_{4}=4\]
Siguiendo el análisis del algoritmo anterior, llegaremos a que la complejidad de la función, estará dada por:
\[T(n)=c_{1}(1.84)^{n}+0.73^{n}(k_{1}\cos(124.68n)+k_{2}\sin(124.68n)))+c_{4}4^{n}\]
Resolviendo las condiciones iniciales:
\[T(0)=c_{1}+k_{1}+c_{4}\]
\[T(1)=1.84c_{1}-0.41k_{1}+0.60k_{2}+4c_{4}\]
\[T(2)=3.38c_{1}-0.18k_{1}-0.49k_{2}+8c_{4}\]
Como $T(3) = T(2) + T(1) + T(0) + 4$ entonces:
\[1+2+2+4 = 6.22c_{1}+0.41k_{1}+0.11k_{2}+13c_{4}+4\]
Luego
\[1=c_{1}+k_{1}+c_{4}\]
\[2=1.84c_{1}-0.41k_{1}+0.60k_{2}+4c_{4}\]
\[2=3.38c_{1}-0.18k_{1}-0.49k_{2}+8c_{4}\]
\[5=6.22c_{1}+0.41k_{1}+0.11k_{2}+13c_{4}\]
Pasando este sistema a la matriz aumentada, tenemos:
\begin{align} 
    \begin{gmatrix}[p] 
        1    &    1  &  0    &  1 & \mline & 1 \\
        1.84 & -0.41 &  0.60 &  4 & \mline & 2 \\
        3.38 & -0.18 & -0.49 &  8 & \mline & 2 \\
        6.22 &  0.41 &  0.11 & 13 & \mline & 5
    \end{gmatrix} 
\end{align}
Resolviendo la matriz por Gauss-Jordan, se llega a la solución:
\begin{align} 
    \begin{gmatrix}[p] 
        1 & 0 & 0 & 0 & \mline & 1.679 \\
        0 & 1 & 0 & 0 & \mline & 0.120 \\
        0 & 0 & 1 & 0 & \mline & 0.930 \\
        0 & 0 & 0 & 1 & \mline &  -0.8
    \end{gmatrix} 
\end{align}
Que es equivalente a que
\[c_{1}=1.679\]
\[k_{1}=0.120\]
\[k_{2}=0.930\]
\[c_{4}=-0.8\]
\center
$\therefore T(n) = 1.679(1.84)^{n}+0.73^{n}[(0.120)\cos(n\theta)+(0.930)\sin(n\theta)]-(0.8)2^{n}$
Con $\theta=124.68$
\newpage
\justify
\textbf{Ejercicio 3:} Resolver las siguientes ecuaciones y dar su orden de complejidad:
\center
$T(n)=3T(n-1)+4T(n-2)$ si $n > 1$; $T(0)=0$, $T(1)=1$
\vspace{10mm}
\newline
$T(n)=2T(n-1)-(n+5)3^{n}$ si $n > 0$; $T(0)=0$
\vspace{10mm}
\newline
$T(n)=3T(n-1)+4T(n-2)+(n+5)2^{n}$ si $n > 1$; $T(0)=0$, $T(1)=100$
\vspace{10mm}
\newline
$T(n)-2T(n-1)=3^{n}$ si $n\geq2$; $T(0)=0$, $T(1)=1$
\newpage
\justify
\textbf{Ejercicio 4:} Calcular la cota de complejidad del algoritmo de búsqueda binaria recursiva:
\newpage
\justify
\textbf{Ejercicio 5:} Calcular la cota de complejidad del algoritmo Merge-Sort recursivo:
\end{document}
