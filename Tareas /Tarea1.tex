\documentclass[12pt, letterpaper, twoside]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsthm}
\usepackage[document]{ragged2e}
\usepackage{listings}
\usepackage{color}
\usepackage{inconsolata}
\definecolor{gris}{rgb}{0.4,0.4,0.4}
\definecolor{verde}{rgb}{0,0.8,0.6}
\definecolor{anaranjado}{rgb}{1.0,0.4,0}
\lstset{
language=C,
basicstyle=\footnotesize\ttfamily,
commentstyle=\color{anaranjado},
frame=single,
keywordstyle=\color{verde},
showspaces=false,
showstringspaces=false,
stringstyle=\color{anaranjado},
tabsize=2
}
 
\title{\textbf{Instituto Politécnico Nacional
			\vspace{10mm}	 \ \newline	
			Escuela Superior de Cómputo}
			\vspace{10mm}	 \ \newline	
			Análisis de Algoritmos
			\vspace{10mm}	 \ \newline	
			Profesor: Edgardo Adrián Martínez Franco}
\author{Alumno: Ortega Victoriano Ivan}
\date{Fecha: 24 de Marzo 2017}
 
\begin{document}
\begin{titlepage}
\maketitle
\end{titlepage}
\justify
\textbf{Análisis de algoritmos no recursivos.}\newline
\textbf{Ejercicio 1:} Encuentre el orden \textit{O} de complejidad temporal y espacial del algoritmo de ordenamiento por Burbuja Simple. 
\begin{lstlisting}
Procedimiento BurbujaSimple(A,n)
	para i=1 hasta (i<n) hacer
		para j=0 hasta (j<n-1) hacer
			si (A[j]>A[j+1]) hacer
				temp = A[j]
				A[j] = A[j+1]
				A[j+1] = temp
			fin si
		fin para
	fin para
fin Procedimiento
\end{lstlisting}
\justify
\textbf{\textit{Sol:}}
Para el análisis temporal se considerarán como operaciones básicas las 3 asignaciones dentro del \textit{if}, la comparación del \textit{if} y los incrementos en los loops. Además, se tomará el peor caso para encontrar la cota \textit{O}.
\newline
Para este algoritmo, el peor caso se da cuando el arreglo esta ordenado de forma descendente, es decir, de mayor a menor, ya que así, siempre estará entrando a la condición del if, ejecutando las 3 asignaciones. Del código, vemos lo siguiente:
\begin{lstlisting}
para i=1 hasta (i<n) hacer       //Compara n veces
	para j=0 hasta (j<n-1) hacer   //Compara n veces
		si (A[j]>A[j+1]) hacer       //1 comparacion
			temp = A[j]                //3 asignaciones
			A[j] = A[j+1]
			A[j+1] = temp
		fin si
	fin para
fin para
\end{lstlisting}
De tal forma que la función de complejidad temporal del algoritmo, estará dada por:
\[f_{t}(n) = (n)(n)(3) = 3n^{2}\]
Ahora para encontrar el orden de complejidad temporal, de acuerdo con la notación de Landau:
\newtheorem*{teo}{Notación de Landau}
\begin{teo}
Se dice que $f(n)$ es de orden $O(g(n))$ si
\center
$\exists c \geq 0$ y $n_{0} \geq 0$ $\mid$ $|f(n)|\leq c|g(n)|$ , $\forall n\geq n_{0}$.
\end{teo}
\justify
Ahora, sea $g(n)=n^{2}$ y $c=4$, vemos que:\newline
Si n=0,
\center$f(0)=3(0)^{2}=0\leq 0 = 4(0)^{2}=g(0)$
\justify
Si n=1,
\center$f(1)=3(1)^{2}=3\leq 4 = 4(1)^{2}=g(1)$
\justify
Si n=2,
\center$f(2)=3(2)^{2}=12\leq 16 = 4(2)^{2}=g(2)$
\justify
En general, se cumple que
\center$|f(n)|\leq c|g(n)|$ , $\forall n\geq n_{0}$.
\justify
De lo que podemos decir que $f_{t}(n)$ es de orden $O(n^{2})$.\newline
\vspace{2mm} \ \newline
Por otro lado, para el análisis espacial, tenemos
\begin{lstlisting}
para i=1 hasta (i<n) hacer     // 1 variable i
	para j=0 hasta (j<n-1) hacer // 1 variable j
		si (A[j]>A[j+1]) hacer  
			temp = A[j]   // 1 variable temp
			A[j] = A[j+1] // n variables del arreglo "A"
			A[j+1] = temp
		fin si
	fin para
fin para
\end{lstlisting}
De tal forma que la función de complejidad espacial del algoritmo estará dada por:
\center
\[f_{e}(n)=3+n\]
\justify
Para encontrar la cota \textit{O} de $f_{e}(n)$, se hace al igual que en el caso anterior.\newline
Sea $g(n)=n$, $c=4$ y $n_{0}=1$, tenemos que\newline
Si n=1,
\center$f(1)=3+1=4\leq 4=4(1)=g(1)$
\justify
Si n=2,
\center$f(2)=3+2=5\leq 8=4(2)=g(2)$
\justify
Si n=3,
\center$f(0)=3+3=6\leq 12=4(3)=g(3)$
\justify
En general, se cumple que
\center$|f(n)|\leq c|g(n)|$ , $\forall n\geq n_{0}$.
\justify
De lo que podemos decir que $f_{e}(n)$ es de orden $O(n)$.
\newpage
\textbf{Ejercicio 2:} Encuentre el orden \textit{O} de complejidad temporal y espacial
del algoritmo de ordenamiento por Inserción. 
\begin{lstlisting}
Procedimiento Insercion(A,n)
	para i=1 hasta i<n hacer
		temp=A[i]
		j=i-1
		mientras((A[j]>temp)&&(j>=0)) hacer
			A[j+1]=A[j]
			j--
		fin mientras
		A[j+1]=temp
	fin para
fin Procedimiento
\end{lstlisting}
\end{document}